<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Particle Life Sandbox (Working Version)</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
    <div id="app">
        <main id="workspace">
            <canvas id="simulation-canvas" width="800" height="600"></canvas>
        </main>

        <aside id="control-panel">
            <div id="connection-status">Initializing...</div>

            <div class="controls">
                <h3>Simulation Controls</h3>
                <div class="control-group">
                    <label for="species-input">Species Count</label>
                    <input type="number" id="species-input" min="1" max="10" value="3" />
                </div>
                <div class="control-group">
                    <label for="particle-input">Particle Count</label>
                    <input type="number" id="particle-input" min="10" max="2000" value="450" />
                </div>
                <button id="apply-settings" class="primary">Apply Settings</button>
            </div>

            <div class="controls">
                <h3>Presets</h3>
                <select id="preset-select">
                    <option value="">Select a preset</option>
                </select>
                <button id="apply-preset">Apply Preset</button>
            </div>

            <div class="controls">
                <button id="reset-config" class="secondary">Reset</button>
            </div>

            <div class="matrix-editor">
                <h3>Interaction Matrix</h3>
                <div id="matrix-table"></div>
            </div>

            <div class="stats">
                <h3>Statistics</h3>
                <ul id="stats-list"></ul>
            </div>
        </aside>
    </div>

    <script>
        const canvas = document.getElementById("simulation-canvas");
        const ctx = canvas.getContext("2d");
        const statusElement = document.getElementById("connection-status");
        const matrixTable = document.getElementById("matrix-table");
        const presetSelect = document.getElementById("preset-select");
        const applyPresetButton = document.getElementById("apply-preset");
        const resetButton = document.getElementById("reset-config");
        const applySettingsButton = document.getElementById("apply-settings");
        const speciesInput = document.getElementById("species-input");
        const particleInput = document.getElementById("particle-input");
        const statsList = document.getElementById("stats-list");

        const baseColors = ["#ff5a5f", "#00a699", "#f7b733", "#3c91e6", "#9b59b6", "#2ecc71"];

        let socket;
        let state = {
            config: null,
            matrix: [],
            particles: [],
            presets: [],
        };
        let matrixInputs = [];
        let frameCount = 0;

        // Connect to WebSocket immediately
        function connect() {
            console.log("Connecting to WebSocket...");
            setStatus("Connecting...");

            const protocol = window.location.protocol === "https:" ? "wss" : "ws";
            socket = new WebSocket(`${protocol}://${window.location.host}/ws`);

            socket.addEventListener("open", () => {
                console.log("WebSocket connected!");
                setStatus("Connected");
                frameCount = 0;
                // Load config and presets after connection
                loadConfig();
                loadPresets();
            });

            socket.addEventListener("close", () => {
                console.log("WebSocket disconnected");
                setStatus("Disconnected – retrying…");
                setTimeout(connect, 2000);
            });

            socket.addEventListener("error", (error) => {
                console.error("WebSocket error:", error);
                setStatus("Connection error");
            });

            socket.addEventListener("message", onMessage);
        }

        function onMessage(event) {
            try {
                const message = JSON.parse(event.data);
                if (message.type === "state") {
                    const payload = message.payload;
                    state.particles = payload.particles;

                    // Check if config/matrix changed
                    const configChanged = JSON.stringify(state.config) !== JSON.stringify(payload.config);
                    const matrixChanged = JSON.stringify(state.matrix) !== JSON.stringify(payload.matrix);

                    state.matrix = payload.matrix;
                    state.config = payload.config;

                    // Throttle UI updates to prevent browser lag
                    frameCount++;
                    if (configChanged || matrixChanged || frameCount % 30 === 0) {
                        populateConfigControls();
                        refreshMatrixEditor();
                        updateStats();
                    }

                    // Always render particles
                    render();
                } else if (message.type === "error") {
                    setStatus(message.detail || "Server error");
                }
            } catch (error) {
                console.error("Error processing message:", error);
            }
        }

        function render() {
            if (!state.particles || state.particles.length === 0) {
                return;
            }

            // Clear canvas with dark background
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw particles with fixed large radius
            const radius = 5;
            for (const particle of state.particles) {
                const color = getSpeciesColor(particle.species);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function getSpeciesColor(index) {
            if (index < baseColors.length) {
                return baseColors[index];
            }
            const hue = (index * 137.508) % 360;
            return `hsl(${Math.round(hue)}, 70%, 55%)`;
        }

        function setStatus(text) {
            statusElement.textContent = text;
        }

        function sendMessage(message) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
            }
        }

        async function loadConfig() {
            try {
                const response = await fetch("/config");
                if (response.ok) {
                    const data = await response.json();
                    state.config = data.config;
                    state.matrix = data.matrix;
                    populateConfigControls();
                    refreshMatrixEditor();
                }
            } catch (error) {
                console.error("Failed to load config:", error);
            }
        }

        async function loadPresets() {
            try {
                const response = await fetch("/presets");
                if (response.ok) {
                    state.presets = await response.json();
                    presetSelect.innerHTML =
                        '<option value="">Select a preset</option>' +
                        state.presets
                            .map((preset) => `<option value="${preset.name}">${preset.name} — ${preset.description}</option>`)
                            .join("");
                }
            } catch (error) {
                console.error("Failed to load presets:", error);
            }
        }

        function populateConfigControls() {
            if (!state.config) return;

            if (document.activeElement !== speciesInput) {
                speciesInput.value = state.config.species_count;
            }
            if (document.activeElement !== particleInput) {
                particleInput.value = state.config.particle_count;
            }
        }

        function refreshMatrixEditor() {
            if (!state.matrix || state.matrix.length === 0) {
                matrixTable.innerHTML = "<p>No matrix data</p>";
                return;
            }

            const size = state.matrix.length;
            let html = '<table>';

            // Header row
            html += '<tr><th></th>';
            for (let i = 0; i < size; i++) {
                html += `<th>S${i+1}</th>`;
            }
            html += '</tr>';

            // Data rows
            for (let i = 0; i < size; i++) {
                html += `<tr><th>S${i+1}</th>`;
                for (let j = 0; j < size; j++) {
                    html += `<td><input type="number" step="0.1" value="${state.matrix[i][j]}"
                             data-row="${i}" data-col="${j}" class="matrix-input" /></td>`;
                }
                html += '</tr>';
            }
            html += '</table>';

            matrixTable.innerHTML = html;

            // Add event listeners
            const inputs = matrixTable.querySelectorAll('.matrix-input');
            inputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        state.matrix[row][col] = value;
                        sendMessage({ type: "update_matrix", matrix: state.matrix });
                    }
                });
            });
        }

        function updateStats() {
            if (!state.config) return;

            const items = [
                `Particles: ${state.particles.length}`,
                `Species: ${state.config.species_count}`,
                `Frame: ${frameCount}`,
            ];
            statsList.innerHTML = items.map((item) => `<li>${item}</li>`).join("");
        }

        // Setup control event listeners
        applySettingsButton.addEventListener("click", async () => {
            const species = parseInt(speciesInput.value);
            const particles = parseInt(particleInput.value);

            if (isNaN(species) || isNaN(particles)) return;

            try {
                const response = await fetch("/config", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        config: {
                            species_count: species,
                            particle_count: particles
                        },
                        reset_matrix: true,
                    }),
                });

                if (response.ok) {
                    const data = await response.json();
                    state.config = data.config;
                    state.matrix = data.matrix;
                    populateConfigControls();
                    refreshMatrixEditor();
                }
            } catch (error) {
                console.error("Failed to update config:", error);
            }
        });

        applyPresetButton.addEventListener("click", () => {
            const selected = presetSelect.value;
            if (selected) {
                sendMessage({ type: "use_preset", name: selected });
            }
        });

        resetButton.addEventListener("click", () => {
            sendMessage({ type: "reset" });
        });

        // Start the application
        console.log("Starting application...");
        connect();
    </script>
</body>
</html>